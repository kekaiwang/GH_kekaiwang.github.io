---
title: Redis 常见面试题
author:
  name: Jugg Wang
  link: https://github.com/kekaiwang
date: 2022-01-20 09:50:00 +0800
last_modified_at: 2022-01-20 15:50:00 +0800
categories: [Interview, Redis]
tags: [面试, redis]
---

### Redis 为什么这么快？

1. **纯内存操作**

    不论读写操作都是在内存上完成的，跟传统的磁盘文件数据存储相比，避免了通过磁盘 IO 读取到内存这部分的开销。

2. **单线程模型**

    避免了频繁的上下文切换和竞争锁机制，也不会出现频繁切换线程导致CPU消耗，不会存在多线程的死锁等一系列问题。

    **单线程指的是 Redis 键值对读写请求的执行是单线程**。Redis 服务在执行一些其他命令时就会使用多线程，对于 Redis 的持久化、集群数据同步、异步删除的指令如 `UNLINK`、`FLUSHALL ASYNC`、`FLUSHDB ASYNC` 等非阻塞的删除操作。

3. **I/O 多路复用模型**

    **Redis 采用 I/O 多路复用技术，并发处理连接。**
    Redis 作为一个内存服务器，它需要处理很多来自外部的网络请求，它**使用 I/O 多路复用机制同时监听多个文件描述符的可读和可写状态，一旦受到网络请求就会在内存中快速处理**，由于绝大多数的操作都是纯内存的，所以处理的速度会非常地快。

4. **高效的数据结构**

    redis 共有 string、list、hash、set、sortedset 五种数据机构

    **SDS 简单动态字符串**

    1 .SDS 中 `len` 保存这字符串的长度，`O(1)` 时间复杂度查询字符串长度信息。  
    2 .**空间预分配**：SDS 被修改后，程序不仅会为 SDS 分配所需要的必须空间，还会分配额外的未使用空间。  
    3 .**惰性空间释放**：当对 SDS 进行缩短操作时，程序并不会回收多余的内存空间，而是使用 free 字段将这些字节数量记录下来不释放，后面如果需要 append 操作，则直接使用 free 中未使用的空间，减少了内存的分配。

    **zipList 压缩列表**

    压缩列表是 List 、hash、 sorted Set 三种数据类型底层实现之一。  
    当一个列表只有少量数据的时候，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么 Redis 就会使用压缩列表来做列表键的底层实现。

    **quicklist**

    **首先在列表元素较少的情况下会使用一块连续的内存存储**，这个结构是 `ziplist`，也就是**压缩列表**。  
    **它将所有的元素紧挨着一起存储，*分配的是一块连续的内存*。当数据量比较多的时候才会改成 `quicklist`**。
    因为普通的链表需要的附加指针空间太大，会比较浪费空间，而且会加重内存的碎片化。

    **skipList 跳跃表**

    sorted set 类型的排序功能便是通过「跳跃列表」数据结构来实现。  
    跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。  
    跳表在链表的基础上，增加了多层级索引，通过索引位置的几个跳转，实现数据的快速定位

    **IntSet 小整数集合**

    当 `set` 集合容纳的元素都是整数并且元素个数较小时，Redis 会使用 `intset` 来存储结合元素。intset 是紧凑的数组结构，同时支持 16 位、32 位和 64 位整数。

5. **简单的 RESP 通信协议**

    RESP 是 Redis 序列化协议的简写。它是一种直观的文本协议，优势在于实现异常简单，解析性能极好。

    Redis 协议将传输的结构数据分为 5 种最小单元类型，单元结束时统一加上回车换行符号 `\r\n`。

    1.**单行字符串**以 + 符号开头。  
    2.**多行字符串** 以 $ 符号开头，后跟字符串长度。  
    3.**整数值**以 : 符号开头，后跟整数的字符串形式。  
    4.**错误消息**以 - 符号开头。  
    5.**数组**以 * 号开头，后跟数组的长度。  

#### 为什么选择单线程？

1. 使用单线程模型能带来更好的可维护性，方便开发和调试
2. 使用单线程模型也能并发的处理客户端的请求
3. Redis 服务中运行的绝大多数操作的性能瓶颈都不是 CPU

### redis 与 memcache 比有什么优势？

1. **数据类型**：memcached 只支持以 key-value 形式访问存取数据，在内存中维护一张巨大的哈希表，从而保证所有查询的时间复杂度是 O(1)；redis 则支持除 key-value 之外的其他数据类型，比如 list、set、hash、zset 等，用来实现队列、有序集合等更复杂的功能；
2. **性能**：memcached 支持多线程，可以利用多核优势，不过也引入了锁，redis 是单线程，在操作大数据方面，memcached 更有优势，处理小数据的时候，redis 更优；
3. **数据持久化**：redis 支持数据同步和持久化存储，memcached 不支持，意味着一旦机器重启所有存储数据将会丢失；
4. **数据一致性**：memcached 提供了 cas 命令来保证，而 redis 提供了事务的功能，可以保证一串命令的原子性，中间不会被任何操作打断 。
5. **分布式**：memcached 本身不支持分布式存储，只能在客户端通过一致性哈希算法实现，属于客户端实现；redis 更倾向于在服务端构建分布式存储，并且 redis 本身就对此提供了支持，即redis cluster。

### 过期策略

1. **定时删除**  
    redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，以后会定时遍历这个字典来删除到期的 key。

2. **惰性删除**  
    惰性策略就是在客户端访问这个 key 的时候，redis 对 key 的过期时间进行检查，如果过期了就立即删除。
    **定时删除是集中处理，惰性删除是零散处理。**

3. **定期删除**  
    Redis 默认会每 100ms 进行一次过期扫描，过期扫描不会遍历过期字典中所有的 key，而是采用了一种简单的**贪心策略**。

    1. 从过期字典中随机 20 个 key
    2. 删除这 20 个 key 中已经过期的 key
    3. **如果过期的 key 比率超过 1/4，那就重复步骤 1**

    同时，为了保证过期扫描不会出现循环过度，导致线程卡死现象，**算法还增加了扫描时间的上限，默认不会超过 25ms。**

#### 对比

**定时删除**对内存友好，能够在 key 过期后立即从内存中删除，但是对 CPU 不友好，如果过期键较多会占用 CPU 对一些时间

**惰性删除**对 CPU 友好，只有在键用到的时候才会进行检查，对于很多用不到的 key 不用浪费时间进行检查，但是对内存不友好，过期 key 如果一直没用到就会一直在内存中，内存就得不到释放，从而造成内存泄漏。

**定期删除**可以通过限制操作时长和频率减少删除对 CPU 的影响，同时也能释放过期 key 占用的内存；但是频率和时长不太好控制，执行频繁了和定时一样占用 CPU，执行太少和惰性删除又一样对内存不好。

一般会使用组合策略 惰性删除 和 定期删除 组合使用。

#### 从库的过期策略

**从库不会进行过期扫描，从库对过期的处理是被动的**。主库在 key 到期时，会在 AOF 文件里增加一条 `del` 指令，同步到所有的从库，从库通过执行这条 `del` 指令来删除过期的 key。

### 内存淘汰策略

为了限制最大使用内存，Redis 提供了配置参数 `maxmemory` 来限制内存超出期望大小。
Redis 提供了几种可选策略 (`maxmemory-policy`) 来让用户自己决定该如何腾出新的空间以继续提供读写服务

1. **noeviction 不删除策略**  
    不会继续服务写请求 (DEL 请求可以继续服务)，读请求可以继续进行。这样可以保证不会丢失数据，但是会让线上的业务不能持续进行。这是默认的淘汰策略。

2. **volatile-lru 尝试淘汰设置了过期时间的 key**  
    最少使用的 key 优先被淘汰。没有设置过期时间的 key 不会被淘汰，这样可以保证需要持久化的数据不会突然丢失。

3. **volatile-ttl 除了淘汰的策略不是 LRU**  
    而是 key 的剩余寿命 ttl 的值，ttl 越小越优先被淘汰。

4. **volatile-random**  
    淘汰的 key 是过期 key 集合中随机的 key。

5. **allkeys-lru**  
    区别于 volatile-lru，这个策略要淘汰的 key 对象是全体的 key 集合，而不只是过期的 key 集合。这意味着没有设置过期时间的 key 也会被淘汰。

6. **allkeys-random**  
    跟上面一样，不过淘汰的策略是随机的 key。

#### LRU 算法

实现 LRU 算法除了需要 key/value 字典外，还需要附加一个链表，链表中的元素按照一定的顺序进行排列。当空间满的时候，会踢掉链表尾部的元素。当字典的某个元素被访问时，它在链表中的位置会被移动到表头。所以链表的元素排列顺序就是元素最近被访问的时间顺序。

位于链表尾部的元素就是不被重用的元素，所以会被踢掉。位于表头的元素就是最近刚刚被人用过的元素，所以暂时不会被踢。

#### 近似 LRU 算法

**Redis 使用的是一种近似 LRU 算法**，它跟 LRU 算法还不太一样。之所以不使用 LRU 算法，是因为需要消耗大量的额外的内存，需要对现有的数据结构进行较大的改造。

*近似 LRU 算法则很简单，在现有数据结构的基础上使用随机采样法来淘汰元素，能达到和 LRU 算法非常近似的效果*。Redis 为实现近似 LRU 算法，它给每个 key 增加了一个额外的小字段，这个字段的长度是 24 个 bit，也就是最后一次被访问的时间戳。

当 Redis 执行写操作时，发现内存超出 maxmemory，就会执行一次 LRU 淘汰算法。这个算法也很简单，就是随机采样出 5(可以配置) 个 key，然后淘汰掉最旧的 key，如果淘汰后内存还是超出 maxmemory，那就继续随机采样淘汰，直到内存低于 maxmemory 为止。

采样按照 `maxmemory-policy` 的配置，如果是 `allkeys` 就是从所有的 key 字典中随机，如果是 `volatile` 就从带过期时间的 key 字典中随机。每次采样多少个 key 看的是 `maxmemory_samples` 的配置，默认为 5。

#### LFU

Redis 4.0 里引入了一个新的淘汰策略 —— LFU 模式，全称是 Least Frequently Used，表示按最近的访问频率进行淘汰，它比 LRU 更加精准地表示了一个 key 被访问的热度。

### Redis 持久化

Redis 的持久化机制有两种，**第一种是快照，第二种是 AOF 日志**。

**快照是一次全量备份，AOF 日志是连续的增量备份**。

***快照*是内存数据的二进制序列化形式，在存储上非常紧凑，而 *AOF 日志记录* 的是内存数据修改的指令记录文本**。

AOF 日志在长期的运行过程中会变的无比庞大，数据库重启时需要加载 AOF 日志进行指令重放，这个时间就会无比漫长。所以需要定期进行 AOF 重写，给 AOF 日志进行瘦身。

#### RDB 快照原理

Redis 使用操作系统的多进程 COW(Copy On Write) 机制来实现快照持久化。

*Redis 在持久化时会调用 glibc 的函数 fork 产生一个子进程，快照持久化完全交给子进程来处理，父进程继续处理客户端请求*。子进程刚刚产生时，它和父进程共享内存里面的代码段和数据段。这是 Linux 操作系统的机制，为了节约内存资源，所以尽可能让它们共享起来。在进程分离的一瞬间，内存的增长几乎没有明显变化。

**子进程做数据持久化，它不会修改现有的内存数据结构，它只是对数据结构进行遍历读取，然后序列化写到磁盘中。但是父进程不一样，它必须持续服务客户端请求，然后对内存数据结构进行不间断的修改**。

随着父进程修改操作的持续进行，越来越多的共享页面被分离出来，内存就会持续增长。但是也不会超过原有数据内存的 2 倍大小。**另外一个 Redis 实例里冷数据占的比例往往是比较高的，所以很少会出现所有的页面都会被分离，被分离的往往只有其中一部分页面。*每个页面的大小只有 4K，一个 Redis 实例里面一般都会有成千上万的页面。***。

子进程因为数据没有变化，它能看到的内存里的数据在进程产生的一瞬间就凝固了，再也不会改变，这也是为什么 Redis 的持久化叫「快照」的原因。接下来子进程就可以非常安心的遍历数据了进行序列化写磁盘了。

#### AOF 原理

**AOF 日志存储的是 Redis 服务器的顺序指令序列，AOF 日志只记录对内存进行修改的指令记录**。

假设 AOF 日志记录了自 Redis 实例创建以来所有的修改性指令序列，那么就可以通过对一个空的 Redis 实例顺序执行所有的指令，也就是「**重放**」，来恢复 Redis 当前实例的内存数据结构的状态。

Redis 会在收到客户端修改指令后，进行参数校验进行逻辑处理后，如果没问题，就立即将该指令文本存储到 AOF 日志中，也就是*先执行指令才将日志存盘*。这点不同于 leveldb、hbase 等存储引擎，它们都是先存储日志再做逻辑处理。

Redis 在长期运行的过程中，AOF 的日志会越变越长。如果实例宕机重启，重放整个 AOF 日志会非常耗时，导致长时间 Redis 无法对外提供服务。所以需要对 AOF 日志瘦身。

##### AOF 重写

Redis 提供了 `bgrewriteaof` 指令用于对 AOF 日志进行瘦身。**其原理就是开辟一个子进程对内存进行遍历转换成一系列 Redis 的操作指令，序列化到一个新的 AOF 日志文件中**。序列化完毕后再将操作期间发生的增量 AOF 日志追加到这个新的 AOF 日志文件中，追加完毕后就立即替代旧的 AOF 日志文件了，瘦身工作就完成了。

> 通常 Redis 的主节点是不会进行持久化操作，持久化操作主要在从节点进行。从节点是备份节点，没有来自客户端请求的压力，它的操作系统资源往往比较充沛。

#### Redis 4.0 混合持久化

重启 Redis 时，*我们很少使用 rdb 来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放*，但是重放 AOF 日志性能相对 rdb 来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。

将 rdb 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是自持久化开始到持久化结束的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小。
![image](https://mail.wangkekai.cn/3354A8D7-3098-4448-81D8-ED5BBF6B0CC6.png)

于是在 Redis 重启的时候，**可以先加载 rdb 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升**。