<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="Go 常见面试题" /><meta name="author" content="Kane Wang" /><meta property="og:locale" content="en" /><meta name="description" content="Go - nil" /><meta property="og:description" content="Go - nil" /><link rel="canonical" href="https://kekai.wang/posts/go-interview/" /><meta property="og:url" content="https://kekai.wang/posts/go-interview/" /><meta property="og:site_name" content="Kane’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-02-08T09:30:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Go 常见面试题" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Kane Wang"},"dateModified":"2023-03-16T14:32:31+08:00","datePublished":"2022-02-08T09:30:00+08:00","description":"Go - nil","headline":"Go 常见面试题","mainEntityOfPage":{"@type":"WebPage","@id":"https://kekai.wang/posts/go-interview/"},"url":"https://kekai.wang/posts/go-interview/"}</script><title>Go 常见面试题 | Kane's Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Kane's Blog"><meta name="application-name" content="Kane's Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://mail.wangkekai.cn/37c5b9f0875c22ddf214c53ca5985d1a" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Kane's Blog</a></div><div class="site-subtitle font-italic">A programmer who knows nothing!</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/kekaiwang" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['wkekai','163.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Go 常见面试题</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Go 常见面试题</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/kekaiwang">Kane Wang</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" date="2022-02-08 09:30:00 +0800" data-toggle="tooltip" data-placement="bottom" title="Tue, Feb 8, 2022, 9:30 AM +0800" >Feb 8, 2022</em> </span> <span> Updated <em class="timeago" date="2023-03-16 14:32:31 +0800 " data-toggle="tooltip" data-placement="bottom" title="Thu, Mar 16, 2023, 2:32 PM +0800" >Mar 16</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6539 words"> <em>36 min</em> read</span></div></div></div><div class="post-content"><h2 id="go---nil">Go - nil<a href="#go---nil" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p><code class="language-plaintext highlighter-rouge">nil</code> 只能赋值给指针、<code class="language-plaintext highlighter-rouge">chan</code>、<code class="language-plaintext highlighter-rouge">func</code>、<code class="language-plaintext highlighter-rouge">interface</code>、<code class="language-plaintext highlighter-rouge">map</code> 或 <code class="language-plaintext highlighter-rouge">slice</code> 类型的变量</p><h2 id="channel">channel<a href="#channel" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Go 语言中，<strong>不要通过共享内存来通信，而要通过通信来实现内存共享</strong>。Go 的 <code class="language-plaintext highlighter-rouge">CSP</code>(Communicating Sequential Process)并发模型，中文叫做<strong>通信顺序进程</strong>，是通过 goroutine 和 channel 来实现的。</p><p><strong>channel 收发遵循先进先出 FIFO，分为有缓存和无缓存</strong>，channel 中大致有 <code class="language-plaintext highlighter-rouge">buffer</code>(当缓冲区大小部位 0 时，是个 <code class="language-plaintext highlighter-rouge">ring buffer</code>)、<code class="language-plaintext highlighter-rouge">sendx</code> 和 <code class="language-plaintext highlighter-rouge">recvx</code> 收发的位置(<code class="language-plaintext highlighter-rouge">ring buffer</code> 记录实现)、<code class="language-plaintext highlighter-rouge">sendq</code>、<code class="language-plaintext highlighter-rouge">recvq</code> 当前 channel 因为缓冲区不足而阻塞的队列、使用双向链表存储、还有一个 <code class="language-plaintext highlighter-rouge">mutex</code> 锁控制并发、其他原属等。</p><h3 id="向通道发送数据">向通道发送数据<a href="#向通道发送数据" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-go highlighter-rouge"><div class="code-header"> <span label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">func</span> <span class="n">chansend</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">hchan</span><span class="p">,</span> <span class="n">ep</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">,</span> <span class="n">block</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">callerpc</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">.</span><span class="n">lock</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">closed</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
        <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">.</span><span class="n">lock</span><span class="p">)</span>
        <span class="nb">panic</span><span class="p">(</span><span class="n">plainError</span><span class="p">(</span><span class="s">"send on closed channel"</span><span class="p">))</span>
    <span class="p">}</span>
</pre></table></code></div></div><p><strong>在发送数据的逻辑执行之前会先为当前 Channel 加锁，防止多个线程并发修改数据。如果 Channel 已经关闭，那么向该 Channel 发送数据时会报 “send on closed channel” 错误并中止程序</strong>。</p><p>执行过程分成以下的三个部分：</p><ul><li><strong>当存在等待的接收者时</strong>，通过 <code class="language-plaintext highlighter-rouge">runtime.send</code> 直接将数据发送给阻塞的接收者；<li><strong>当缓冲区存在空余空间时</strong>，将发送的数据写入 Channel 的缓冲区；<li><strong>当不存在缓冲区或者缓冲区已满时</strong>，等待其他 Goroutine 从 Channel 接收数据；</ul><h4 id="发送数据">发送数据<a href="#发送数据" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>如果当前 Channel 的 <code class="language-plaintext highlighter-rouge">recvq</code> 上存在已经被阻塞的 Goroutine，那么会直接将数据发送给当前 Goroutine 并将其设置成下一个运行的 Goroutine，<strong>也就是将接收方的 Goroutine 放到了处理器的 <code class="language-plaintext highlighter-rouge">runnext</code> 中，程序没有立刻执行该 Goroutine</strong><blockquote><p>向一个非缓冲型的 channel 发送数据、从一个无元素的（非缓冲型或缓冲型但空）的 channel 接收数据，都会导致一个 goroutine 直接操作另一个 goroutine 的栈, 由于 GC 假设对栈的写操作只能发生在 goroutine 正在运行中并且由当前 goroutine 来写, 所以这里实际上违反了这个假设。可能会造成一些问题，<strong>所以需要用到写屏障来规避</strong></p></blockquote><li>如果 Channel 存在缓冲区并且其中还有空闲的容量，我们会直接将数据存储到缓冲区 <code class="language-plaintext highlighter-rouge">sendx</code> 所在的位置上；<li>如果不满足上面的两种情况，会创建一个 <code class="language-plaintext highlighter-rouge">runtime.sudog</code> 结构并将其加入 Channel 的 <code class="language-plaintext highlighter-rouge">sendq</code> 队列中，当前 Goroutine 也会陷入阻塞等待其他的协程从 Channel 接收数据；</ul><h3 id="接收数据">接收数据<a href="#接收数据" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-go highlighter-rouge"><div class="code-header"> <span label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">func</span> <span class="n">chanrecv</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">hchan</span><span class="p">,</span> <span class="n">ep</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">,</span> <span class="n">block</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="n">selected</span><span class="p">,</span> <span class="n">received</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">!</span><span class="n">block</span> <span class="p">{</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="n">gopark</span><span class="p">(</span><span class="no">nil</span><span class="p">,</span> <span class="no">nil</span><span class="p">,</span> <span class="n">waitReasonChanReceiveNilChan</span><span class="p">,</span> <span class="n">traceEvGoStop</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span>
        <span class="n">throw</span><span class="p">(</span><span class="s">"unreachable"</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">.</span><span class="n">lock</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">closed</span> <span class="o">!=</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">.</span><span class="n">qcount</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
        <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">.</span><span class="n">lock</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ep</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
            <span class="n">typedmemclr</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">elemtype</span><span class="p">,</span> <span class="n">ep</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="no">true</span><span class="p">,</span> <span class="no">false</span>
    <span class="p">}</span>
</pre></table></code></div></div><p><strong>当我们从一个空 Channel 接收数据时会直接调用 <code class="language-plaintext highlighter-rouge">runtime.gopark</code> 让出处理器的使用权。</strong></p><p>使用 <code class="language-plaintext highlighter-rouge">runtime.chanrecv</code> 从 Channel 接收数据时还包含以下三种不同情况：</p><ol><li><strong>当存在等待的发送者时</strong>，通过 <code class="language-plaintext highlighter-rouge">runtime.recv</code> 从阻塞的发送者或者缓冲区中获取数据；<li><strong>当缓冲区存在数据时</strong>，从 Channel 的缓冲区中接收数据；<li><strong>当缓冲区中不存在数据时</strong>，等待其他 Goroutine 向 Channel 发送数据；</ol><p>直接接收数据时根据缓冲区的大小分别处理不同的情况：</p><ul><li><strong>如果 Channel 不存在缓冲区</strong>；<ol><li>调用 <code class="language-plaintext highlighter-rouge">runtime.recvDirect</code> 将 Channel 发送队列中 Goroutine 存储的 <code class="language-plaintext highlighter-rouge">elem</code> 数据拷贝到目标内存地址中；</ol><li><strong>如果 Channel 存在缓冲区</strong>；<ol><li>将队列中的数据拷贝到接收方的内存地址；<li>将发送队列头的数据拷贝到缓冲区中，释放一个阻塞的发送方；</ol></ul><p><strong>无论发生哪种情况，运行时都会调用 <code class="language-plaintext highlighter-rouge">runtime.goready</code> 将当前处理器的 <code class="language-plaintext highlighter-rouge">runnext</code> 设置成发送数据的 Goroutine，在调度器下一次调度时将阻塞的发送方唤醒。</strong></p><h4 id="从通道接收数据">从通道接收数据<a href="#从通道接收数据" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><ol><li>如果 Channel 为空，那么会直接调用 <code class="language-plaintext highlighter-rouge">runtime.gopark</code> 挂起当前 Goroutine；<li>如果 Channel 已经关闭并且缓冲区没有任何数据，<code class="language-plaintext highlighter-rouge">runtime.chanrecv</code> 会直接返回；<li>如果 Channel 的 <code class="language-plaintext highlighter-rouge">sendq</code> 队列中存在挂起的 Goroutine，会将 <code class="language-plaintext highlighter-rouge">recvx</code> 索引所在的数据拷贝到接收变量所在的内存空间上并将 <code class="language-plaintext highlighter-rouge">sendq</code> 队列中 Goroutine 的数据拷贝到缓冲区；<li>如果 Channel 的缓冲区中包含数据，那么直接读取 <code class="language-plaintext highlighter-rouge">recvx</code> 索引对应的数据；<li>在默认情况下会挂起当前的 Goroutine，将 <code class="language-plaintext highlighter-rouge">runtime.sudog</code> 结构加入 <code class="language-plaintext highlighter-rouge">recvq</code> 队列并陷入休眠等待调度器的唤醒；</ol><h3 id="触发调度时机">触发调度时机<a href="#触发调度时机" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ol><li><strong>发送数据时</strong><ol><li>发送数据时发现 Channel 上存在等待接收数据的 Goroutine，立刻设置处理器的 <code class="language-plaintext highlighter-rouge">runnext</code> 属性，但是并不会立刻触发调度；<li>发送数据时并没有找到接收方并且缓冲区已经满了，这时会将自己加入 Channel 的 <code class="language-plaintext highlighter-rouge">sendq</code> 队列并调用 <code class="language-plaintext highlighter-rouge">runtime.goparkunlock</code> 触发 Goroutine 的调度让出处理器的使用权；</ol><li><p><strong>从 Channel 接收数据时，会触发 Goroutine 调度的两个时机</strong>：</p><ol><li>当 Channel 为空时；<li>当缓冲区中不存在数据并且也不存在数据的发送者时；</ol></ol><h3 id="channel-最佳实践">channel 最佳实践<a href="#channel-最佳实践" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><strong>读已经关闭的 <code class="language-plaintext highlighter-rouge">chan</code> 能⼀直读到东⻄，但是读到的内容根据通道内关闭前是否有元素⽽不同。</strong><ol><li>如果 <code class="language-plaintext highlighter-rouge">chan</code> 关闭前，<code class="language-plaintext highlighter-rouge">buffer</code> 内有元素还未读, 会正确读到 <code class="language-plaintext highlighter-rouge">chan</code> 内的值，且返回的第⼆个 <code class="language-plaintext highlighter-rouge">bool</code> 值（是否读成功）为 <code class="language-plaintext highlighter-rouge">true</code>。<li>如果 <code class="language-plaintext highlighter-rouge">chan</code> 关闭前，<code class="language-plaintext highlighter-rouge">buffer</code> 内有元素已经被读完，<code class="language-plaintext highlighter-rouge">chan</code> 内⽆值，接下来所有接收的值都会⾮阻塞直接成功，返回 <code class="language-plaintext highlighter-rouge">channel</code> 元素的零值，但是第⼆个 <code class="language-plaintext highlighter-rouge">bool</code> 值⼀直为 <code class="language-plaintext highlighter-rouge">false</code>。</ol><li><strong>触发 <code class="language-plaintext highlighter-rouge">panic</code> 的情况</strong><ol><li><strong>向已经关闭的 <code class="language-plaintext highlighter-rouge">chan</code> 发送数据会 <code class="language-plaintext highlighter-rouge">panic</code></strong><li>关闭一个 <code class="language-plaintext highlighter-rouge">nil</code> 的 channel；<li>重复关闭一个 channel。</ol><li>向 <code class="language-plaintext highlighter-rouge">nil</code> 的通道发送或接收数据会调用 <code class="language-plaintext highlighter-rouge">gopark</code> 挂起，并陷入永久阻塞<li>channel 泄漏 <strong>泄漏的原因是 goroutine 操作 channel 后，处于发送或接收阻塞状态，而 channel 处于满或空的状态，一直得不到改变</strong>。同时，垃圾回收器也不会回收此类资源，进而导致 gouroutine 会一直处于等待队列中，不见天日。</ul><h2 id="runtime-包中的常用方法">runtime 包中的常用方法<a href="#runtime-包中的常用方法" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ol><li><code class="language-plaintext highlighter-rouge">NumCPU</code>: 返回当前系统的 CPU 核数量<li><p><code class="language-plaintext highlighter-rouge">GOMAXPROCS</code>: 设置最大的可同时使用的 CPU 核数</p><blockquote><p>通过 <code class="language-plaintext highlighter-rouge">runtime.GOMAXPROCS</code> 函数，应用程序何以在运行期间设置运行时系统中得 P 最大数量。但这会引起 “Stop the World”。所以，应在应用程序最早的调用。并且最好是在运行Go程序之前设置好操作程序的环境变量 GOMAXPROCS，而不是在程序中调用 runtime.GOMAXPROCS 函数。</p></blockquote><p>无论我们传递给函数的整数值是什么值，运行时系统的P最大值总会在1~256之间。</p><li><code class="language-plaintext highlighter-rouge">Gosched</code>:让当前线程让出 cpu 以让其它线程运行,它不会挂起当前线程，因此当前线程未来会继续执行<br /> 这个函数的作用是让当前 goroutine 让出 CPU，当一个 goroutine 发生阻塞，Go 会自动地把与该 goroutine 处于同一系统线程的其他 goroutine 转移到另一个系统线程上去，以使这些 goroutine 不阻塞。<li><code class="language-plaintext highlighter-rouge">Goexit</code>: 退出当前 goroutine(但是defer语句会照常执行)<li><code class="language-plaintext highlighter-rouge">NumGoroutine</code>: 返回正在执行和排队的任务总数<br /> runtime.NumGoroutine 函数在被调用后，会返回系统中的处于特定状态的 Goroutine 的数量。这里的特指是指 Grunnable\Gruning\Gsyscall\Gwaition。处于这些状态的 Groutine 即被看做是活跃的或者说正在被调度。 注意：垃圾回收所在 Groutine 的状态也处于这个范围内的话，也会被纳入该计数器。<li><code class="language-plaintext highlighter-rouge">GOOS</code>: 目标操作系统<li><code class="language-plaintext highlighter-rouge">GC</code>: 会让运行时系统进行一次强制性的垃圾收集 1.强制的垃圾回收：不管怎样，都要进行的垃圾回收。2.非强制的垃圾回收：只会在一定条件下进行的垃圾回收（即运行时，系统自上次垃圾回收之后新申请的堆内存的单元（也成为单元增量）达到指定的数值）。<li><code class="language-plaintext highlighter-rouge">GOROOT</code>: 获取 goroot 目录<li><code class="language-plaintext highlighter-rouge">GOOS</code>: 查看目标操作系统</ol><h2 id="垃圾回收">垃圾回收<a href="#垃圾回收" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>追踪式标记清除</p><h3 id="gc-的根对象是什么">GC 的根对象是什么？<a href="#gc-的根对象是什么" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ol><li><strong>全局变量</strong>：程序在编译期就能确定的那些存在于程序整个生命周期的变量。<li><strong>执行栈</strong>：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。<li><strong>寄存器</strong>：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。</ol><h3 id="三色标记">三色标记<a href="#三色标记" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><blockquote><p>三色抽象只是一种描述追踪式回收器的方法，在实践中并没有实际含义，它的重要作用在于从逻辑上严密推导标记清理这种垃圾回收方法的正确性。</p></blockquote><p>垃圾回收器的视角来看，三色抽象规定了三种不同类型的对象，并用不同的颜色相称：</p><ul><li><strong>白色对象</strong>（可能死亡）：未被回收器访问到的对象。在回收开始阶段，所有对象均为白色，当回收结束后，白色对象均不可达。<li><strong>灰色对象</strong>（波面）：已被回收器访问到的对象，但回收器需要对其中的一个或多个指针进行扫描，因为他们可能还指向白色对象。<li><strong>黑色对象</strong>（确定存活）：已被回收器访问到的对象，其中所有字段都已被扫描，黑色对象中任何一个指针都不可能直接指向白色对象。</ul><p>这样三种不变性所定义的回收过程其实是一个波面不断前进的过程，这个波面同时也是黑色对象和白色对象的边界，灰色对象就是这个波面。</p><p><strong>悬挂指针</strong>，即指针没有指向特定类型的合法对象，影响了内存的安全性，想要并发或者增量地标记对象还是需要使用屏障技术。</p><h3 id="屏障技术">屏障技术<a href="#屏障技术" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><strong>强三色不变性</strong> — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象<li><strong>弱三色不变性</strong> — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径</ul><h4 id="插入写屏障">插入写屏障<a href="#插入写屏障" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><div class="language-go highlighter-rouge"><div class="code-header"> <span label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">writePointer</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span><span class="o">:</span>
    <span class="n">shade</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span>
    <span class="o">*</span><span class="n">slot</span> <span class="o">=</span> <span class="n">ptr</span>
</pre></table></code></div></div><p>Dijkstra 的插入写屏障是一种相对保守的屏障技术，<strong>它会将有存活可能的对象都标记成灰色以满足强三色不变性</strong>。</p><p>垃圾收集和用户程序交替运行时将黑色对象 A 指向白色对象 B，会将对象 B 标记成灰色，完成插入写屏障也就满足了强三色不变性。</p><p>插入式的 Dijkstra 写屏障虽然实现非常简单并且也能保证强三色不变性，但是它也有明显的缺点。因为栈上的对象在垃圾收集中也会被认为是根对象，所以为了保证内存的安全，Dijkstra 必须为栈上的对象增加写屏障或者在标记阶段完成重新对栈上的对象进行扫描，这两种方法各有各的缺点，前者会大幅度增加写入指针的额外开销，后者重新扫描栈对象时需要暂停程序，垃圾收集算法的设计者需要在这两者之间做出权衡。</p><h4 id="删除写屏障">删除写屏障<a href="#删除写屏障" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>会在老对象的引用被删除时，将白色的老对象涂成灰色，这样删除写屏障就可以保证弱三色不变性，老对象引用的下游对象一定可以被灰色对象引用。</p><p>垃圾收集和用户程序交替运行时黑色对象 A 指向灰色对象 B，B 指向白色对象 C，此时 A 指向 C，因为灰色对象 B 指向白色对象 C，此时不触发删除写屏障，如果将灰色对象 B 原本指向白色对象 C 的指针删除，会将对象 C 标记成灰色，完成删除写屏障也就满足了强/弱三色不变性。</p><h4 id="混合写屏障">混合写屏障<a href="#混合写屏障" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>在 Go 语言 v1.7 版本之前，运行时会使用 Dijkstra 插入写屏障保证强三色不变性，但是运行时并没有在所有的垃圾收集根对象上开启插入写屏障。因为应用程序可能包含成百上千的 Goroutine，而垃圾收集的根对象一般包括全局变量和栈对象，如果运行时需要在几百个 Goroutine 的栈上都开启写屏障，会带来巨大的额外开销，<strong>所以 Go 团队在实现上选择了在标记阶段完成时暂停程序、将所有栈对象标记为灰色并重新扫描，在活跃 Goroutine 非常多的程序中，重新扫描的过程需要占用 10 ~ 100ms 的时间</strong>。</p><p><strong>会将被覆盖的对象标记成灰色并在当前栈没有扫描时将新对象也标记成灰色</strong>。</p><p>为了移除栈的重扫描过程，除了引入混合写屏障之外，<strong>在垃圾收集的标记阶段，我们还需要将创建的所有新对象都标记成黑色，防止新分配的栈内存和堆内存中的对象被错误地回收</strong>，因为栈内存在标记阶段最终都会变为黑色，所以不再需要重新扫描栈空间。</p><h3 id="增量和并发">增量和并发<a href="#增量和并发" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p><strong>增量垃圾收集</strong> — 增量地标记和清除垃圾，降低应用程序暂停的最长时间</p><p>增量式（Incremental）的垃圾收集是减少程序最长暂停时间的一种方案，它可以将原本时间较长的暂停时间切分成多个更小的 GC 时间片，虽然从垃圾收集开始到结束的时间更长了，但是这也减少了应用程序暂停的最大时间；</p><p>为了保证垃圾收集的正确性，我们需要在垃圾收集开始前打开写屏障，这样用户程序修改内存都会先经过写屏障的处理，保证了堆内存中对象关系的强三色不变性或者弱三色不变性。虽然增量式的垃圾收集能够减少最大的程序暂停时间，但是增量式收集也会增加一次 GC 循环的总时间，在垃圾收集期间，因为写屏障的影响用户程序也需要承担额外的计算开销，所以增量式的垃圾收集也不是只带来好处的，但是总体来说还是利大于弊。</p><li><p><strong>并发垃圾收集</strong> — 利用多核的计算资源，在用户程序执行时并发标记和清除垃圾</p><p>并发（Concurrent）的垃圾收集不仅能够减少程序的最长暂停时间，还能减少整个垃圾收集阶段的时间，通过开启读写屏障、利用多核优势与用户程序并行执行，并发垃圾收集器确实能够减少垃圾收集对应用程序的影响</p><p>虽然并发收集器能够与用户程序一起运行，但是并不是所有阶段都可以与用户程序一起运行，部分阶段还是需要暂停用户程序的，不过与传统的算法相比，并发的垃圾收集可以将能够并发执行的工作尽量并发执行；当然，因为读写屏障的引入，并发的垃圾收集器也一定会带来额外开销，不仅会增加垃圾收集的总时间，还会影响用户程序，这是我们在设计垃圾收集策略时必须要注意的。</p></ul><h3 id="垃圾收集的阶段">垃圾收集的阶段<a href="#垃圾收集的阶段" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ol><li>清理终止阶段 <strong>STW</strong><ol><li>暂停程序，所有的处理器在这时会进入安全点（Safe point）；<li>如果当前垃圾收集循环是强制触发的，我们还需要处理还未被清理的内存管理单元；</ol><li>标记阶段<ol><li>将状态切换至 <code class="language-plaintext highlighter-rouge">_GCmark</code>、开启写屏障、用户程序协助（Mutator Assists）并将根对象入队；<li>恢复执行程序，标记进程和用于协助的用户程序会开始并发标记内存中的对象，<strong>写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新创建的对象都会被直接标记成黑色</strong>；<li>开始扫描根对象，包括所有 Goroutine 的栈、全局对象以及不在堆中的运行时数据结构，扫描 Goroutine 栈期间会暂停当前处理器；<li>依次处理灰色队列中的对象，将对象标记成黑色并将它们指向的对象标记成灰色；<li>使用分布式的终止算法检查剩余的工作，发现标记阶段完成后进入标记终止阶段；</ol><li>标记终止阶段 <strong>STW</strong><ol><li>暂停程序、将状态切换至 <code class="language-plaintext highlighter-rouge">_GCmarktermination</code> 并关闭辅助标记的用户程序；<li>清理处理器上的线程缓存；</ol><li>清理阶段<ol><li>将状态切换至 <code class="language-plaintext highlighter-rouge">_GCoff</code> 开始清理阶段，初始化清理状态并关闭写屏障；<li>恢复用户程序，所有新创建的对象会标记成白色；<li>后台并发清理所有的内存管理单元，当 Goroutine 申请新的内存管理单元时就会触发清理</ol></ol><p><code class="language-plaintext highlighter-rouge">runtime.work</code> 变量：该结构体中包含大量垃圾收集的相关字段，例如：表示完成的垃圾收集循环的次数、当前循环时间和 CPU 的利用率、垃圾收集的模式等等，我们会在后面的小节中见到该结构体中的更多字段。</p><h3 id="gc-触发时机">GC 触发时机<a href="#gc-触发时机" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Go 语言中对 GC 的触发时机存在两种形式：</p><ol><li><p><strong>主动触发</strong>，通过调用 <code class="language-plaintext highlighter-rouge">runtime.GC</code> 来触发 GC，此调用阻塞式地等待当前 GC 运行完毕。</p><li><p><strong>被动触发</strong>，分为两种方式：</p><ul><li>使用系统监控，如果一定时间内没有触发，就会触发新的循环，该触发条件由 runtime.forcegcperiod 变量控制，默认为 2 分钟；<li>使用步调（Pacing）算法，其核心思想是控制内存增长的比例。</ul><li><p>申请内存</p><p>最后一个可能会触发垃圾收集的就是 <code class="language-plaintext highlighter-rouge">runtime.mallocgc</code> 了，我们在上一节内存分配器中曾经介绍过运行时会将堆上的对象按大小分成微对象、小对象和大对象三类，这三类对象的创建都可能会触发新的垃圾收集循环：</p><ol><li>当前线程的内存管理单元中不存在空闲空间时，创建微对象和小对象需要调用 <code class="language-plaintext highlighter-rouge">runtime.mcache.nextFree</code> 从中心缓存或者页堆中获取新的管理单元，在这时就可能触发垃圾收集；<li>当用户程序申请分配 32KB 以上的大对象时，一定会构建 <code class="language-plaintext highlighter-rouge">runtime.gcTrigger</code> 结构体尝试触发垃圾收集；</ol><p>通过堆内存触发垃圾收集需要比较 <code class="language-plaintext highlighter-rouge">runtime.mstats</code> 中的两个字段 — 表示垃圾收集中存活对象字节数的 <code class="language-plaintext highlighter-rouge">heap_live</code> 和表示触发标记的堆内存大小的 <code class="language-plaintext highlighter-rouge">gc_trigger</code>；当内存中存活的对象字节数大于触发垃圾收集的堆大小时，新一轮的垃圾收集就会开始。在这里，我们将分别介绍这两个值的计算过程：</p><ul><li><code class="language-plaintext highlighter-rouge">heap_live</code> — 为了减少锁竞争，运行时只会在中心缓存分配或者释放内存管理单元以及在堆上分配大对象时才会更新；<li><code class="language-plaintext highlighter-rouge">gc_trigger</code> — 在标记终止阶段调用 <code class="language-plaintext highlighter-rouge">runtime.gcSetTriggerRatio</code> 更新触发下一次垃圾收集的堆大小；</ul></ol><h3 id="gc-如何调优">GC 如何调优<a href="#gc-如何调优" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>通过 <code class="language-plaintext highlighter-rouge">go tool pprof</code> 和 <code class="language-plaintext highlighter-rouge">go tool trace</code> 等工具<li>控制内存分配的速度，限制 goroutine 的数量，从而提高赋值器对 CPU 的利用率。<li>减少并复用内存，例如使用 <code class="language-plaintext highlighter-rouge">sync.Pool</code> 来复用需要频繁创建临时对象，例如提前分配足够的内存来降低多余的拷贝。<li>需要时，增大 <code class="language-plaintext highlighter-rouge">GOGC</code> 的值，降低 GC 的运行频率。</ul><h3 id="gc-跟不上分配的速度">GC 跟不上分配的速度<a href="#gc-跟不上分配的速度" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>目前的 Go 实现中，当 GC 触发后，会首先进入并发标记的阶段。并发标记会设置一个标志，并在 mallocgc 调用时进行检查。当存在新的内存分配时，会暂停分配内存过快的那些 goroutine，并将其转去执行一些辅助标记（Mark Assist）的工作，从而达到放缓继续分配、辅助 GC 的标记工作的目的。</p><h2 id="内存分配">内存分配<a href="#内存分配" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="内存逃逸">内存逃逸<a href="#内存逃逸" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p><strong>逃逸分析最基本的原则</strong>: 编译器会分析代码的特征和代码生命周期，Go 中的变量只有在编译器可以证明在函数返回后不会再被引用的，才分配到栈上，其他情况下都是分配到堆上。</p><p><em>引起变量逃逸到堆上的典型情况</em>：</p><ul><li><strong>在⽅法内把局部变量指针返回</strong>, 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引⽤，因此其⽣命周期⼤于栈，则溢出。<li><strong>发送指针或带有指针的值到 <code class="language-plaintext highlighter-rouge">channel</code> 中</strong>。在编译时，是没有办法知道哪个 <code class="language-plaintext highlighter-rouge">goroutine</code> 会在 <code class="language-plaintext highlighter-rouge">channel</code> 上接收数据。所以编译器没法知道变量什么时候才会被释放。<li><strong>在⼀个切⽚上存储指针或带指针的值</strong>。⼀个典型的例⼦就是 <code class="language-plaintext highlighter-rouge">[]*string</code>。这会导致切⽚的内容逃逸。尽管其后⾯的数组可能是在栈上分配的，但其引⽤的值⼀定是在堆上。<li><strong><code class="language-plaintext highlighter-rouge">slice</code> 的背后数组被重新分配了，因为 <code class="language-plaintext highlighter-rouge">append</code> 时可能会超出其容量(<code class="language-plaintext highlighter-rouge">cap</code>)</strong>。<code class="language-plaintext highlighter-rouge">slice</code> 初始化的地⽅在编译时是可以知道的，它最开始会在栈上分配。如果切⽚背后的存储要基于运⾏时的数据进⾏扩充，就会在堆上分配。<li><p><strong>在 <code class="language-plaintext highlighter-rouge">interface</code> 类型上调⽤⽅法</strong>。在 <code class="language-plaintext highlighter-rouge">interface</code> 类型上调⽤⽅法都是动态调度的⽅法的真正实现只能在运⾏时知道。想像⼀个 <code class="language-plaintext highlighter-rouge">io.Reader</code> 类型的变量 <code class="language-plaintext highlighter-rouge">r</code> , 调⽤ <code class="language-plaintext highlighter-rouge">r.Read(b)</code> 会使得 <code class="language-plaintext highlighter-rouge">r</code> 的值和切⽚ <code class="language-plaintext highlighter-rouge">b</code> 的背后存储都逃逸掉，所以会在堆上分配。</p><li><strong>闭包的捕获变量也会分配到堆上，还有就是大对象 大于 32KB</strong></ul><h3 id="new-一个对象最后在堆上还是栈上就根据上面的逃逸分析进行回答">new 一个对象最后在堆上还是栈上就根据上面的逃逸分析进行回答<a href="#new-一个对象最后在堆上还是栈上就根据上面的逃逸分析进行回答" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><h2 id="defer">defer<a href="#defer" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p><code class="language-plaintext highlighter-rouge">defer</code> 关键字的实现跟 <code class="language-plaintext highlighter-rouge">go</code> 关键字很类似，不同的是它调⽤的是 <code class="language-plaintext highlighter-rouge">runtime.deferproc</code> ⽽不是 <code class="language-plaintext highlighter-rouge">runtime.newproc</code>。 在 <code class="language-plaintext highlighter-rouge">defer</code> 出现的地⽅，插⼊了指令 <code class="language-plaintext highlighter-rouge">call runtime.deferproc</code>，然后在函数返回之前的地⽅，插⼊指令 <code class="language-plaintext highlighter-rouge">call runtime.deferreturn</code>。 goroutine 的控制结构中，有⼀张表记录 <code class="language-plaintext highlighter-rouge">defer</code>，调⽤ <code class="language-plaintext highlighter-rouge">runtime.deferproc</code> 时会将需要 <code class="language-plaintext highlighter-rouge">defer</code> 的表达式记录在表中，⽽在调⽤ <code class="language-plaintext highlighter-rouge">runtime.deferreturn</code> 的时候，则会依次从 <code class="language-plaintext highlighter-rouge">defer</code> 表中出栈并执⾏。 因此，题⽬最后输出顺序应该是 defer 定义顺序的倒序。 panic 错误并不能终⽌ defer 的执⾏。</p><h2 id="继承与多态">继承与多态<a href="#继承与多态" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-go highlighter-rouge"><div class="code-header"> <span label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">type</span> <span class="n">People</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Speak</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Stduent</span> <span class="k">struct</span><span class="p">{}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">stu</span> <span class="o">*</span><span class="n">Stduent</span><span class="p">)</span> <span class="n">Speak</span><span class="p">(</span><span class="n">think</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="n">talk</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">think</span> <span class="o">==</span> <span class="s">"love"</span> <span class="p">{</span>
        <span class="n">talk</span> <span class="o">=</span> <span class="s">"You are a good boy"</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">talk</span> <span class="o">=</span> <span class="s">"hi"</span>
    <span class="p">}</span>
    <span class="k">return</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">peo</span> <span class="n">People</span> <span class="o">=</span> <span class="n">Stduent</span><span class="p">{}</span>
    <span class="n">think</span> <span class="o">:=</span> <span class="s">"love"</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">peo</span><span class="o">.</span><span class="n">Speak</span><span class="p">(</span><span class="n">think</span><span class="p">))</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在 golang 中对多态的特点体现从语法上并不是很明显。</p><p>我们知道发生多态的几个要素：</p><ol><li>有 <code class="language-plaintext highlighter-rouge">interface</code> 接口，并且有接口定义的方法。<li>有子类去重写 <code class="language-plaintext highlighter-rouge">interface</code> 的接口。<li>有父类指针指向子类的具体对象</ol><p>那么，满足上述 3 个条件，就可以产生多态效果，就是，父类指针可以调用子类的具体方法。</p><p>所以上述代码报错的地方在 <code class="language-plaintext highlighter-rouge">var peo People = Stduent{}</code> 这条语句， <code class="language-plaintext highlighter-rouge">Student{}</code> 已经重写了父类 <code class="language-plaintext highlighter-rouge">People{}</code> 中的 <code class="language-plaintext highlighter-rouge">Speak(string) string</code> 方法，那么只需要用父类指针指向子类对象即可。（Go 中不叫父类，这里是为了好理解）</p><p>所以应该改成 <code class="language-plaintext highlighter-rouge">var peo People = &amp;Student{}</code> 即可编译通过。（People 为 <code class="language-plaintext highlighter-rouge">interface</code> 类型，就是指针类型）</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/go/'>Go</a>, <a href='/categories/interview/'>Interview</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E9%9D%A2%E8%AF%95/" class="post-tag no-text-decoration" >面试</a> <a href="/tags/go/" class="post-tag no-text-decoration" >Go</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Go 常见面试题 - Kane's Blog&url=https://kekai.wang/posts/go-interview/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Go 常见面试题 - Kane's Blog&u=https://kekai.wang/posts/go-interview/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Go 常见面试题 - Kane's Blog&url=https://kekai.wang/posts/go-interview/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recent Update</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/dev-standard/">Golang 开发规范 -- Go Code Review Comments</a><li><a href="/posts/new-first/">Getting Started</a><li><a href="/posts/go-interview/">Go 常见面试题</a><li><a href="/posts/mysql-index/">MySQL 索引及常见面试题</a><li><a href="/posts/innodb-myisam/">MySQL - InnoDB 和 MyISAM 的区别</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/go/">Go</a> <a class="post-tag" href="/tags/redis/">Redis</a> <a class="post-tag" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a> <a class="post-tag" href="/tags/develop/">develop</a> <a class="post-tag" href="/tags/index/">index</a> <a class="post-tag" href="/tags/innodb/">InnoDB</a> <a class="post-tag" href="/tags/myisam/">MyISAM</a> <a class="post-tag" href="/tags/notes/">notes</a> <a class="post-tag" href="/tags/%E7%B4%A2%E5%BC%95/">索引</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/dev-standard/"><div class="card-body"> <em class="timeago small" date="2021-04-18 15:00:00 +0800" >Apr 18, 2021</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Golang 开发规范 -- Go Code Review Comments</h3><div class="text-muted small"><p> 疫情期间入职新公司一个月了，部门每月会有知识分享，由大家轮流进行！ 我们的主力开发语言由 PHP 在逐步转向Go，参考 Go Code Review Comments 在上一次的部门分享我做的是 Go 语言的开发规范，在官方的基础上做了一个简单的分类，供大家参考共同学习。 格式化 gofmt 通过gofmt自动格式化代码，以保证所有的go代码与官方推荐的格式保持一致。 首字母大写和缩...</p></div></div></a></div><div class="card"> <a href="/posts/redis-interview/"><div class="card-body"> <em class="timeago small" date="2022-01-20 09:50:00 +0800" >Jan 20, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Redis 常见面试题</h3><div class="text-muted small"><p> Redis 为什么这么快？ 纯内存操作 不论读写操作都是在内存上完成的，跟传统的磁盘文件数据存储相比，避免了通过磁盘 IO 读取到内存这部分的开销。 单线程模型 避免了频繁的上下文切换和竞争锁机制，也不会出现频繁切换线程导致CPU消耗，不会存在多线程的死锁等一系列问题。 单线程指的是 Redis 键值对读写请求的执行是单线程...</p></div></div></a></div><div class="card"> <a href="/posts/slice/"><div class="card-body"> <em class="timeago small" date="2022-03-15 21:00:00 +0800" >Mar 15, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Slice</h3><div class="text-muted small"><p> slice 底层结构 切片在运行时的表现是 SliceHeader 结构体，定义如下： 1 2 3 4 5 6 type SliceHeader struct { Data uintptr Len int Cap int } Data：指向具体的底层数组。 Len：代表切片的长度。 Cap：代表切片的容量。 要点是：切片真正存储数据的地方，是一个数组。...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/redis-interview/" class="btn btn-outline-primary" prompt="Older"><p>Redis 常见面试题</p></a> <a href="/posts/slice/" class="btn btn-outline-primary" prompt="Newer"><p>Slice</p></a></div><script src="https://utteranc.es/client.js" repo="kekaiwang/kekaiwang.github.io" issue-term="" crossorigin="anonymous" async> </script> <script type="text/javascript"> $(function() { const origin = "https://utteranc.es"; const iframe = "iframe.utterances-frame"; const lightTheme = "github-light"; const darkTheme = "github-dark"; let initTheme = lightTheme; if ($("html[mode=dark]").length > 0 || ($("html[mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } addEventListener("message", (event) => { let theme; /* credit to <https://github.com/utterance/utterances/issues/170#issuecomment-594036347> */ if (event.origin === origin) { /* page initial */ theme = initTheme; } else if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); } else { return; } const message = { type: "set-theme", theme: theme }; const utterances = document.querySelector(iframe).contentWindow; utterances.postMessage(message, origin); }); }); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/kekaiwang">Kane Wang</a>. <span data-toggle="tooltip" data-placement="top" title="Hear have noting...">A programmer who knows nothing!</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/go/">Go</a> <a class="post-tag" href="/tags/redis/">Redis</a> <a class="post-tag" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a> <a class="post-tag" href="/tags/develop/">develop</a> <a class="post-tag" href="/tags/index/">index</a> <a class="post-tag" href="/tags/innodb/">InnoDB</a> <a class="post-tag" href="/tags/myisam/">MyISAM</a> <a class="post-tag" href="/tags/notes/">notes</a> <a class="post-tag" href="/tags/%E7%B4%A2%E5%BC%95/">索引</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
