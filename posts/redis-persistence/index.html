<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="Redis 持久化" /><meta name="author" content="王铁匠" /><meta property="og:locale" content="en" /><meta name="description" content="Redis 持久化" /><meta property="og:description" content="Redis 持久化" /><link rel="canonical" href="https://kekai.wang/posts/redis-persistence/" /><meta property="og:url" content="https://kekai.wang/posts/redis-persistence/" /><meta property="og:site_name" content="Kane’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-04-17T22:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Redis 持久化" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"王铁匠"},"dateModified":"2022-04-17T22:00:00+08:00","datePublished":"2022-04-17T22:00:00+08:00","description":"Redis 持久化","headline":"Redis 持久化","mainEntityOfPage":{"@type":"WebPage","@id":"https://kekai.wang/posts/redis-persistence/"},"url":"https://kekai.wang/posts/redis-persistence/"}</script><title>Redis 持久化 | Kane's Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Kane's Blog"><meta name="application-name" content="Kane's Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://mail.wangkekai.cn/37c5b9f0875c22ddf214c53ca5985d1a" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Kane's Blog</a></div><div class="site-subtitle font-italic">A programmer who knows nothing!</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/kekaiwang" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['wkekai','163.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Redis 持久化</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Redis 持久化</h1><div class="post-meta text-muted"><div> By <em> <a href="https://kekai.wang/">王铁匠</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" date="2022-04-17 22:00:00 +0800" data-toggle="tooltip" data-placement="bottom" title="Sun, Apr 17, 2022, 10:00 PM +0800" >Apr 17, 2022</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4525 words"> <em>25 min</em> read</span></div></div></div><div class="post-content"><h2 id="redis-持久化"><strong>Redis 持久化</strong><a href="#redis-持久化" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Redis 的持久化机制有两种</p><ol><li><strong>第一种是快照 RDB，是一次全量备份</strong><li><strong>第二种是 AOF 日志，是连续的增量备份</strong></ol><p><strong><em>快照</em>是内存数据的二进制序列化形式，在存储上非常紧凑，而 <em>AOF 日志记录</em> 的是内存数据修改的指令记录文本</strong>。</p><p>AOF 日志在长期的运行过程中会变的无比庞大，数据库重启时需要加载 AOF 日志进行指令重放，这个时间就会无比漫长。所以需要定期进行 AOF 重写，给 AOF 日志进行瘦身。</p><h3 id="rdb-快照持久化"><strong>RDB 快照持久化</strong><a href="#rdb-快照持久化" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Redis 提供了两个命令来生成 RDB 文件，分别是 <code class="language-plaintext highlighter-rouge">save</code> 和 <code class="language-plaintext highlighter-rouge">bgsave</code>，他们的区别就在于是否在「主线程」里执行：</p><ul><li>执行了 <code class="language-plaintext highlighter-rouge">save</code> 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，<strong>会阻塞主线程</strong>；<li>执行了 <code class="language-plaintext highlighter-rouge">bgsave</code> 命令，会创建一个子进程来生成 RDB 文件，这样可以<strong>避免主线程的阻塞</strong>；</ul><p>Redis 还可以通过配置文件的选项来实现每隔一段时间自动执行一次 <code class="language-plaintext highlighter-rouge">bgsave</code> 命令，默认会提供以下配置：</p><div class="language-go highlighter-rouge"><div class="code-header"> <span label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">save</span> <span class="m">900</span> <span class="m">1</span>
<span class="n">save</span> <span class="m">300</span> <span class="m">10</span>
<span class="n">save</span> <span class="m">60</span> <span class="m">10000</span>
</pre></table></code></div></div><p>别看选项名叫 <code class="language-plaintext highlighter-rouge">save</code>，实际上执行的是 <code class="language-plaintext highlighter-rouge">bgsave</code> 命令，也就是会创建子进程来生成 RDB 快照文件。</p><p>只要满足上面条件的任意一个，就会执行 bgsave，它们的意思分别是：</p><ul><li>900 秒之内，对数据库进行了至少 1 次修改；<li>300 秒之内，对数据库进行了至少 10 次修改；<li>60 秒之内，对数据库进行了至少 10000 次修改。</ul><p>我们知道 Redis 是单线程程序，这个线程要同时负责多个客户端套接字的并发读写操作和内存数据结构的逻辑读写。</p><p>在服务线上请求的同时，Redis 还需要进行内存快照，内存快照要求 Redis 必须进行文件 IO 操作，可文件 IO 操作是不能使用多路复用 API。</p><p>这意味着单线程同时在服务线上的请求还要进行文件 IO 操作，文件 IO 操作会严重拖垮服务器请求的性能。还有个重要的问题是为了不阻塞线上的业务，就需要边持久化边响应客户端请求。持久化的同时，内存数据结构还在改变，比如一个大型的 hash 字典正在持久化，结果一个请求过来把它给删掉了，还没持久化完呢，这尼玛要怎么搞？</p><p><strong>Redis 使用操作系统的多进程 COW(Copy On Write) 机制来实现快照持久化</strong>。</p><h3 id="fork-多进程"><strong>fork 多进程</strong><a href="#fork-多进程" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p><em>Redis 在持久化时会调用 glibc 的函数 fork 产生一个子进程，快照持久化完全交给子进程来处理，父进程继续处理客户端请求</em>。子进程刚刚产生时，它和父进程共享内存里面的代码段和数据段。这是 Linux 操作系统的机制，为了节约内存资源，所以尽可能让它们共享起来。在进程分离的一瞬间，内存的增长几乎没有明显变化。</p><p>执行 <code class="language-plaintext highlighter-rouge">bgsave</code> 命令的时候，会通过 <code class="language-plaintext highlighter-rouge">fork()</code> 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个，此时如果主线程执行读操作，则主线程和 <code class="language-plaintext highlighter-rouge">bgsave</code> 子进程互相不影响。</p><p><strong>子进程做数据持久化，它不会修改现有的内存数据结构，它只是对数据结构进行遍历读取，然后序列化写到磁盘中。但是父进程不一样，它必须持续服务客户端请求，然后对内存数据结构进行不间断的修改</strong>。</p><p>随着父进程修改操作的持续进行，越来越多的共享页面被分离出来，内存就会持续增长。但是也不会超过原有数据内存的 2 倍大小。<strong>另外一个 Redis 实例里冷数据占的比例往往是比较高的，所以很少会出现所有的页面都会被分离，被分离的往往只有其中一部分页面。<em>每个页面的大小只有 4K，一个 Redis 实例里面一般都会有成千上万的页面。</em></strong>。</p><p>子进程因为数据没有变化，它能看到的内存里的数据在进程产生的一瞬间就凝固了，再也不会改变，这也是为什么 Redis 的持久化叫「快照」的原因。接下来子进程就可以非常安心的遍历数据了进行序列化写磁盘了。</p><p>如果主线程（父进程）要<strong>修改共享数据里的某一块数据</strong>（比如键值对 <code class="language-plaintext highlighter-rouge">A</code>）时，就会发生写时复制，于是这块数据的<strong>物理内存就会被复制一份（键值对 <code class="language-plaintext highlighter-rouge">A'</code>）</strong>，然后<strong>主线程在这个数据副本（键值对 <code class="language-plaintext highlighter-rouge">A'</code>）进行修改操作</strong>。与此同时，<strong>bgsave 子进程可以继续把原来的数据（键值对 <code class="language-plaintext highlighter-rouge">A</code>）写入到 RDB 文件</strong>。</p><p>所以 Redis 在使用 bgsave 快照过程中，如果主线程修改了内存数据，不管是否是共享的内存数据，RDB 快照都无法写入主线程刚修改的数据，因为此时主线程（父进程）的内存数据和子进程的内存数据已经分离了，子进程写入到 RDB 文件的内存数据只能是原本的内存数据。</p><h2 id="aof-持久化"><strong>AOF 持久化</strong><a href="#aof-持久化" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p><strong>AOF (<em>Append Only File</em>) 日志存储的是 Redis 服务器的顺序指令序列，AOF 日志只记录对内存进行修改的指令记录</strong>。</p><p>在 Redis 中 AOF 持久化功能默认是不开启的，需要我们修改 <code class="language-plaintext highlighter-rouge">redis.conf</code> 配置文件中的以下参数：</p><div class="language-go highlighter-rouge"><div class="code-header"> <span label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">appendonly</span> <span class="n">no</span>
<span class="n">appendfilename</span> <span class="s">"appendonly.aof"</span>
</pre></table></code></div></div><p>AOF 日志文件其实就是普通的文本，我们可以通过 <code class="language-plaintext highlighter-rouge">cat</code> 命令查看里面的内容</p><p>Redis 会在收到客户端修改指令后，<strong><em>先执行指令才将日志存盘</em></strong>，进行参数校验进行逻辑处理后，如果没问题，就立即将该指令文本存储到 AOF 日志中。这点不同于 leveldb、hbase 等存储引擎，它们都是先存储日志再做逻辑处理。</p><p><strong>先执行指令再将日志存盘的好处</strong>：</p><ol><li><strong>避免 AOF 写入的额外检查开销，</strong>因为如果先将写操作命令记录到 AOF 日志里，再执行该命令的话，如果当前的命令语法有问题，那么如果不进行命令语法检查，该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错。而如果先执行写操作命令再记录日志的话，只有在该命令执行成功后，才将命令记录到 AOF 日志里，这样就不用额外的检查开销，保证记录在 AOF 日志里的命令都是可执行并且正确的。<li><strong>不会阻塞当前写操作命令的执行</strong>，因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。</ol><p><strong>先执行指令再将日志存盘的风险</strong>：</p><ol><li>执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，<strong>数据就会有丢失的风险</strong>。<li>由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前写操作命令的执行，但是可能会给「下一个」命令带来阻塞风险。</ol><h3 id="redis-写入-aof-步骤"><strong>Redis 写入 AOF 步骤</strong><a href="#redis-写入-aof-步骤" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ol><li>Redis 执行完写操作命令后，会将命令追加到 <code class="language-plaintext highlighter-rouge">server.aof_buf</code> 缓冲区；<li>然后通过 <code class="language-plaintext highlighter-rouge">write()</code> 系统调用，将 <code class="language-plaintext highlighter-rouge">aof_buf</code> 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 <code class="language-plaintext highlighter-rouge">page cache</code>，等待内核将数据写入硬盘；<li>具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。</ol><h3 id="appendfsync-写回策略"><strong><code class="language-plaintext highlighter-rouge">appendfsync</code> 写回策略</strong><a href="#appendfsync-写回策略" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Redis 提供的 AOF 配置项 <code class="language-plaintext highlighter-rouge">appendfsync</code> 写回策略直接决定 AOF 持久化功能的效率和安全性。</p><ul><li><strong>always</strong>：同步写回，写指令执行完毕立马将 <code class="language-plaintext highlighter-rouge">aof_buf</code> 缓冲区中的内容刷写到 AOF 文件。<li><strong>everysec</strong>：每秒写回，写指令执行完，日志只会写到 AOF 文件缓冲区，每隔一秒就把缓冲区内容同步到磁盘。<li><strong>no</strong>：操作系统控制，写执行执行完毕，把日志写到 AOF 文件内存缓冲区，由操作系统决定何时刷写到磁盘。</ul><p>这 3 种写回策略都无法能完美解决 <strong>「主进程阻塞」和「减少数据丢失」的问题</strong>，原因如下：</p><ol><li><strong>Always 策略</strong> 可以最大程度保证数据不丢失，但是由于它每执行一条写操作命令就同步将 AOF 内容写回硬盘，所以是不可避免会影响主进程的性能；<li><strong>No 策</strong>略 是交由操作系统来决定何时将 AOF 日志内容写回硬盘，相比于 Always 策略性能较好，但是操作系统写回硬盘的时机是不可预知的，如果 AOF 日志内容没有写回硬盘，一旦服务器宕机，就会丢失不定数量的数据。<li><strong>Everysec 策略</strong> 是折中的一种方式，避免了 Always 策略的性能开销，也比 No 策略更能避免数据丢失，当然如果上一秒的写操作命令日志没有写回到硬盘，发生了宕机，这一秒内的数据自然也会丢失。</ol><p><strong><code class="language-plaintext highlighter-rouge">fsync()</code></strong></p><p>AOF 日志是以文件的形式存在的，当程序对 AOF 日志文件进行写操作时，<strong><em>实际上是将内容写到了内核为文件描述符分配的一个内存缓存中，然后内核会异步将脏数据刷回到磁盘的</em></strong>。</p><p>Linux 的 glibc提供了 <code class="language-plaintext highlighter-rouge">fsync(int fd)</code> 函数可以将指定文件的内容强制从内核缓存刷到磁盘。 <strong>只要 Redis 进程实时调用 fsync 函数就可以保证 aof 日志不丢失。但是 fsync 是一个磁盘 IO 操作，它很慢</strong>！如果 Redis 执行一条指令就要 fsync 一次，那么 Redis 高性能的地位就不保了。</p><p>所以在生产环境的服务器中，Redis 通常是每隔 1s 左右执行一次 fsync 操作，周期 1s 是可以配置的。这是在数据安全性和性能之间做了一个折中，在保持高性能的同时，尽可能使得数据少丢失。</p><p>Redis 同样也提供了另外两种策略，<strong>一个是 NO fsync——让操作系统来决定何时同步磁盘，很不安全，另一个是来一个指令就 always fsync 一次——非常慢</strong>。</p><ul><li>Always 策略就是每次写入 AOF 文件数据后，就执行 fsync() 函数；<li>Everysec 策略就会创建一个异步任务来执行 fsync() 函数；<li>No 策略就是永不执行 fsync() 函数;</ul><blockquote><p>通常 Redis 的主节点是不会进行持久化操作，持久化操作主要在从节点进行。从节点是备份节点，没有来自客户端请求的压力，它的操作系统资源往往比较充沛。</p></blockquote><h3 id="aof-重写"><strong>AOF 重写</strong><a href="#aof-重写" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Redis 在长期运行的过程中，AOF 的日志会越变越长。如果实例宕机重启，重放整个 AOF 日志会非常耗时，导致长时间 Redis 无法对外提供服务。所以需要对 AOF 日志瘦身。</p><p>Redis 提供了 <code class="language-plaintext highlighter-rouge">bgrewriteaof</code> 指令用于对 AOF 日志进行瘦身。 <strong>其原理就是开辟一个子进程对内存进行遍历转换成一系列 Redis 的操作指令，序列化到一个新的 AOF 日志文件中</strong>。 序列化完毕后再将操作期间发生的增量 AOF 日志追加到这个新的 AOF 日志文件中，追加完毕后就立即替代旧的 AOF 日志文件了，瘦身工作就完成了。</p><ol><li>主进程可以继续处理命令请求，从而避免阻塞主进程<li>子进程带有主进程的数据副本，这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。 而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。</ol><p>主进程在通过 <code class="language-plaintext highlighter-rouge">fork</code> 系统调用生成 <code class="language-plaintext highlighter-rouge">bgrewriteaof</code> 子进程时，操作系统会把主进程的「<strong>页表</strong>」复制一份给子进程，这个页表记录着虚拟地址和物理地址映射关系，而不会复制物理内存，也就是说，<em>两者的虚拟空间不同，但其对应的物理空间是同一个</em>。</p><p>这样一来，子进程就共享了父进程的物理内存数据了，这样能够<strong>节约物理内存资源</strong>，页表对应的页表项的属性会标记该物理内存的权限为<strong>只读</strong>。</p><p>不过，当父进程或者子进程在向这个内存发起写操作时，CPU 就会触发<strong>写保护中断</strong>，这个写保护中断是由于违反权限导致的，然后操作系统会在「写保护中断处理函数」里进行<strong>物理内存的复制</strong>，并重新设置其内存映射关系，将父子进程的内存读写权限设置为<strong>可读写</strong>，最后才会对内存进行写操作，这个过程被称为「<strong>写时复制(<em>Copy On Write</em>)</strong>」。</p><p>有两个阶段会导致阻塞父进程：</p><ul><li>创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；<li>创建完子进程后，如果子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长；</ul><p>在 <code class="language-plaintext highlighter-rouge">bgrewriteaof</code> 子进程执行 AOF 重写期间，主进程需要执行以下三个工作:</p><ul><li>执行客户端发来的命令；<li>将执行后的写命令追加到 「AOF 缓冲区」；<li>将执行后的写命令追加到 「AOF 重写缓冲区」；</ul><h3 id="redis-40-混合持久化"><strong>Redis 4.0 混合持久化</strong><a href="#redis-40-混合持久化" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>重启 Redis 时，<em>我们很少使用 rdb 来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放</em>，但是重放 AOF 日志性能相对 rdb 来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。</p><p>将 rdb 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是自持久化开始到持久化结束的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小。</p><p><img data-src="https://mail.wangkekai.cn/3354A8D7-3098-4448-81D8-ED5BBF6B0CC6.png" alt="image" data-proofer-ignore></p><p>于是在 Redis 重启的时候，<strong>可以先加载 rdb 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升</strong>。</p><p>混合持久化工作在 <strong>AOF 日志重写过程</strong>。</p><p>当开启了混合持久化时，在 AOF 重写日志时，<code class="language-plaintext highlighter-rouge">fork</code> 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p><p>重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样<strong>加载的时候速度会很快</strong>。</p><p>加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得<strong>数据更少的丢失</strong>。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/redis/'>Redis</a>, <a href='/categories/rdb-afo/'>RDB&AFO</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/redis/" class="post-tag no-text-decoration" >Redis</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Redis 持久化 - Kane's Blog&url=https://kekai.wang/posts/redis-persistence/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Redis 持久化 - Kane's Blog&u=https://kekai.wang/posts/redis-persistence/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Redis 持久化 - Kane's Blog&url=https://kekai.wang/posts/redis-persistence/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recent Update</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/dev-standard/">Golang 开发规范 -- Go Code Review Comments</a><li><a href="/posts/new-first/">Getting Started</a><li><a href="/posts/go-interview/">Go 常见面试题</a><li><a href="/posts/mysql-index/">MySQL 索引及常见面试题</a><li><a href="/posts/innodb-myisam/">MySQL - InnoDB 和 MyISAM 的区别</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/go/">Go</a> <a class="post-tag" href="/tags/redis/">Redis</a> <a class="post-tag" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a> <a class="post-tag" href="/tags/develop/">develop</a> <a class="post-tag" href="/tags/index/">index</a> <a class="post-tag" href="/tags/innodb/">InnoDB</a> <a class="post-tag" href="/tags/myisam/">MyISAM</a> <a class="post-tag" href="/tags/notes/">notes</a> <a class="post-tag" href="/tags/%E7%B4%A2%E5%BC%95/">索引</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/redis-interview/"><div class="card-body"> <em class="timeago small" date="2022-01-20 09:50:00 +0800" >Jan 20, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Redis 常见面试题</h3><div class="text-muted small"><p> Redis 为什么这么快？ 纯内存操作 不论读写操作都是在内存上完成的，跟传统的磁盘文件数据存储相比，避免了通过磁盘 IO 读取到内存这部分的开销。 单线程模型 避免了频繁的上下文切换和竞争锁机制，也不会出现频繁切换线程导致CPU消耗，不会存在多线程的死锁等一系列问题。 单线程指的是 Redis 键值对读写请求的执行是单线程...</p></div></div></a></div><div class="card"> <a href="/posts/go-map/"><div class="card-body"> <em class="timeago small" date="2022-04-01 22:00:00 +0800" >Apr 1, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Map</h3><div class="text-muted small"><p> map 结构 hmap map 类型的变量本质上是一个 hmap 类型的指针： type hmap struct { count int // 已经存储的键值对个数 flags uint8 B uint8 // 常规桶个数等于2^B; map底层的哈希表通过与运算的方式选择桶 noverflow uint16 // ...</p></div></div></a></div><div class="card"> <a href="/posts/slice/"><div class="card-body"> <em class="timeago small" date="2022-03-15 21:00:00 +0800" >Mar 15, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Slice</h3><div class="text-muted small"><p> slice 底层结构 切片在运行时的表现是 SliceHeader 结构体，定义如下： type SliceHeader struct { Data uintptr Len int Cap int } Data：指向具体的底层数组。 Len：代表切片的长度。 Cap：代表切片的容量。 要点是：切片真正存储数据的地方，是一个数组。切片的 Data 属性中...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/go-map/" class="btn btn-outline-primary" prompt="Older"><p>Map</p></a> <span class="btn btn-outline-primary disabled" prompt="Newer"><p>-</p></span></div><script src="https://utteranc.es/client.js" repo="kekaiwang/kekaiwang.github.io" issue-term="" crossorigin="anonymous" async> </script> <script type="text/javascript"> $(function() { const origin = "https://utteranc.es"; const iframe = "iframe.utterances-frame"; const lightTheme = "github-light"; const darkTheme = "github-dark"; let initTheme = lightTheme; if ($("html[mode=dark]").length > 0 || ($("html[mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } addEventListener("message", (event) => { let theme; /* credit to <https://github.com/utterance/utterances/issues/170#issuecomment-594036347> */ if (event.origin === origin) { /* page initial */ theme = initTheme; } else if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); } else { return; } const message = { type: "set-theme", theme: theme }; const utterances = document.querySelector(iframe).contentWindow; utterances.postMessage(message, origin); }); }); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/kekaiwang">Kane Wang</a>. <span data-toggle="tooltip" data-placement="top" title="Hear have noting...">A programmer who knows nothing!</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/go/">Go</a> <a class="post-tag" href="/tags/redis/">Redis</a> <a class="post-tag" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a> <a class="post-tag" href="/tags/develop/">develop</a> <a class="post-tag" href="/tags/index/">index</a> <a class="post-tag" href="/tags/innodb/">InnoDB</a> <a class="post-tag" href="/tags/myisam/">MyISAM</a> <a class="post-tag" href="/tags/notes/">notes</a> <a class="post-tag" href="/tags/%E7%B4%A2%E5%BC%95/">索引</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
