<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://kekai.wang/</id><title>Kane's Blog</title><subtitle>wangkekai, kekaiwang, Kane, 王铁匠, A programmer who knows nothing.</subtitle> <updated>2023-03-24T14:39:14+08:00</updated> <author> <name>Kane Wang</name> <uri>https://kekai.wang/</uri> </author><link rel="self" type="application/atom+xml" href="https://kekai.wang/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://kekai.wang/"/> <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator> <rights> © 2023 Kane Wang </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Redis 持久化</title><link href="https://kekai.wang/posts/redis-persistence/" rel="alternate" type="text/html" title="Redis 持久化" /><published>2022-04-17T22:00:00+08:00</published> <updated>2022-04-17T22:00:00+08:00</updated> <id>https://kekai.wang/posts/redis-persistence/</id> <content src="https://kekai.wang/posts/redis-persistence/" /> <author> <name>{"name"=>"王铁匠", "link"=>"https://kekai.wang/"}</name> </author> <category term="Redis" /> <category term="RDB&amp;AFO" /> <summary> Redis 持久化 Redis 的持久化机制有两种 第一种是快照 RDB，是一次全量备份 第二种是 AOF 日志，是连续的增量备份 快照是内存数据的二进制序列化形式，在存储上非常紧凑，而 AOF 日志记录 的是内存数据修改的指令记录文本。 AOF 日志在长期的运行过程中会变的无比庞大，数据库重启时需要加载 AOF 日志进行指令重放，这个时间就会无比漫长。所以需要定期进行 AOF 重写，给 AOF 日志进行瘦身。 RDB 快照持久化 Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave，他们的区别就在于是否在「主线程」里执行： 执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，会阻塞主线程； 执行了 bgsave 命令，会创建一个子进程来生成 R... </summary> </entry> <entry><title>Map</title><link href="https://kekai.wang/posts/go-map/" rel="alternate" type="text/html" title="Map" /><published>2022-04-01T22:00:00+08:00</published> <updated>2022-04-01T22:00:00+08:00</updated> <id>https://kekai.wang/posts/go-map/</id> <content src="https://kekai.wang/posts/go-map/" /> <author> <name>{"name"=>"王铁匠", "link"=>"https://kekai.wang/"}</name> </author> <category term="Go" /> <category term="Map" /> <summary> map 结构 hmap map 类型的变量本质上是一个 hmap 类型的指针： type hmap struct { count int // 已经存储的键值对个数 flags uint8 B uint8 // 常规桶个数等于2^B; map底层的哈希表通过与运算的方式选择桶 noverflow uint16 // 使用的溢出桶数量 hash0 uint32 // hash seed buckets unsafe.Pointer // 常规桶起始地址 oldbuckets unsafe.Pointer // 扩容时保存原来常规桶的地址 nevacuate uintptr // 渐进式扩容时记录下一个要被迁移的旧桶编号 extra *map... </summary> </entry> <entry><title>Slice</title><link href="https://kekai.wang/posts/slice/" rel="alternate" type="text/html" title="Slice" /><published>2022-03-15T21:00:00+08:00</published> <updated>2022-03-15T21:00:00+08:00</updated> <id>https://kekai.wang/posts/slice/</id> <content src="https://kekai.wang/posts/slice/" /> <author> <name>{"name"=>"王铁匠", "link"=>"https://kekai.wang/"}</name> </author> <category term="Go" /> <category term="Slice" /> <summary> slice 底层结构 切片在运行时的表现是 SliceHeader 结构体，定义如下： type SliceHeader struct { Data uintptr Len int Cap int } Data：指向具体的底层数组。 Len：代表切片的长度。 Cap：代表切片的容量。 要点是：切片真正存储数据的地方，是一个数组。切片的 Data 属性中存储的是指向所引用的数组指针地址。 可以将切片理解成一片连续的内存空间加上长度与容量的标识. 初始化切片 arr := arr[1:3] // 下标 arr := []int{1, 2, 3} // 字面量 arr := make([]int, 2, 3) // 关键字 使用下标初始化切片 不会拷贝原数组或者原切片中... </summary> </entry> <entry><title>Go 常见面试题</title><link href="https://kekai.wang/posts/go-interview/" rel="alternate" type="text/html" title="Go 常见面试题" /><published>2022-02-08T09:30:00+08:00</published> <updated>2023-03-16T14:32:31+08:00</updated> <id>https://kekai.wang/posts/go-interview/</id> <content src="https://kekai.wang/posts/go-interview/" /> <author> <name>{"name"=>"Kane Wang", "link"=>"https://github.com/kekaiwang"}</name> </author> <category term="Go" /> <category term="Interview" /> <summary> Go - nil nil 只能赋值给指针、chan、func、interface、map 或 slice 类型的变量 channel Go 语言中，不要通过共享内存来通信，而要通过通信来实现内存共享。Go 的 CSP(Communicating Sequential Process)并发模型，中文叫做通信顺序进程，是通过 goroutine 和 channel 来实现的。 channel 收发遵循先进先出 FIFO，分为有缓存和无缓存，channel 中大致有 buffer(当缓冲区大小部位 0 时，是个 ring buffer)、sendx 和 recvx 收发的位置(ring buffer 记录实现)、sendq、recvq 当前 channel 因为缓冲区不足而阻塞的队列、使用双向链表存储、还有一个 mutex 锁控制并发、其他原属等。 向通道发送数据 func c... </summary> </entry> <entry><title>Redis 常见面试题</title><link href="https://kekai.wang/posts/redis-interview/" rel="alternate" type="text/html" title="Redis 常见面试题" /><published>2022-01-20T09:50:00+08:00</published> <updated>2022-02-07T22:50:00+08:00</updated> <id>https://kekai.wang/posts/redis-interview/</id> <content src="https://kekai.wang/posts/redis-interview/" /> <author> <name>{"name"=>"Kane Wang", "link"=>"https://github.com/kekaiwang"}</name> </author> <category term="Redis" /> <category term="Interview" /> <summary> Redis 为什么这么快？ 纯内存操作 不论读写操作都是在内存上完成的，跟传统的磁盘文件数据存储相比，避免了通过磁盘 IO 读取到内存这部分的开销。 单线程模型 避免了频繁的上下文切换和竞争锁机制，也不会出现频繁切换线程导致CPU消耗，不会存在多线程的死锁等一系列问题。 单线程指的是 Redis 键值对读写请求的执行是单线程。Redis 服务在执行一些其他命令时就会使用多线程，对于 Redis 的持久化、集群数据同步、异步删除的指令如 UNLINK、FLUSHALL ASYNC、FLUSHDB ASYNC 等非阻塞的删除操作。 I/O 多路复用模型 Redis 采用 I/O 多路复用技术，并发处理连接。 Redis 作为一个内存服务器，它需要处理很多来自外部的网络请求，它使用 I/O ... </summary> </entry> </feed>
